<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python_book_阅读笔记1]]></title>
    <url>%2F2018%2F08%2F14%2Fpython-book-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[前言：这是《Python Cookbook》Release 3.0.0 的读书笔记。这篇是读完第一张，觉得需要记录的点。 《Python Cookbook》这本书学的很有意思，并不是只是串讲而是分方面，一个点一个点的介绍python中的一些技巧，库方法等，在实际工作中十分有用。在我读完，发现以前有一些我不知道的方法，遇到类似问题就自己写个方法什么的。读完之后，在一些方面可以提升效率。 1. heapq模块：1.1. 最小堆：12345nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]import heapqheap = list(nums)heapq.heapify(heap)heap # [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8] 1.2. 查找最大或最小N个元素nlargest()和nsmallest()函数1234import heapqnums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]print(heapq.nlargest(3, nums)) # Prints [42, 37, 23]print(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2] nlargest()和nsmallest()也有key参数 1.3. 实现一个优先级队列12345678910111213141516import heapqclass PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority): heapq.heappush(self._queue, (-priority, self._index, item)) # -priority保证优先级从高到底 self._index += 1 ''' index 变量的作用是保证同等优先级元素的正确排序。 通过保存一个不断增加的index 下标变量,可以确保元素按照它们插入的顺序排序。 ''' def pop(self): return heapq.heappop(self._queue)[-1] push和pop时间复杂度O(logN) 2. 字典：2.1. multidict：一个键映射多个值，用列表保存。 之前：12345d = &#123;&#125;for key, value in pairs:if key not in d:d[key] = []d[key].append(value) 可以使用defaultdict。defaultdict 的一个特征是它会自动初始化每个 key 刚开始对应的值,所以你只需要关注添加元素操作了1234from collections import defaultdictd = defaultdict(list)for key, value in pairs:d[key].append(value) 2.2. 有序字典用collections模块中的OrderedDict类。在迭代操作的时候它会保持元素被插入时的顺序123456789from collections import OrderedDictd = OrderedDict()d['foo'] = 1d['bar'] = 2d['spam'] = 3d['grok'] = 4# Outputs "foo 1", "bar 2", "spam 3", "grok 4"for key in d: print(key, d[key]) 在python 3.6+，字典dict使用了新的实现方式，内存占用比之前减少20%-25%，且字典有序。 2.3. 字典排序通过使用 operator 模块的 itemgetter 函数12from operator import itemgetterrows_by_fname = sorted(rows, key=itemgetter('fname')) rows_by_uid = sorted(rows, key=itemgetter('uid')) itemgetter() 函数也支持多个 keys1rows_by_lfname = sorted(rows, key=itemgetter('lname','fname')) itemgetter()方法对应对象的__getitem__()方法 itemgetter()方法和lambda表达式效果相同，但itemgetter()方法速度稍快 2.4 字典运算最大值 最小值：1min_v = min(zip(dict.values(), dict.keys())) 使用zip将字典反转为value-key形式 2.5 两个字典相同点123456# Find keys in commona.keys() &amp; b.keys() # &#123; 'x', 'y' &#125;# Find keys in a that are not in ba.keys() - b.keys() # &#123; 'z' &#125;# Find (key,value) pairs in commona.items() &amp; b.items() # &#123; ('y', 2) &#125; 同样可以利用字典推倒来构建字典，排除一些key123# Make a new dictionary with certain keys removedc = &#123;key:a[key] for key in a.keys() - &#123;'z', 'w'&#125;&#125;# c is &#123;'x': 1, 'y': 2&#125; 2.6. 字典推导字典推导式：p1 = {key: value for key, value in prices.items() if value &gt; 200} 通过元组传值p1 = dict((key, value) for key, value in prices.items() if value &gt; 200) 字典推导式更快(大概快一倍!!) 2.7. 字典合并 使用 collections 模块中的 ChainMap 类1234from collections import ChainMap c = ChainMap(a,b)print(c['x']) # Outputs 1 (from a)print(c['y']) # Outputs 2 (from b)print(c['z']) # Outputs 3 (from a) 一个 ChainMap 接受多个字典并将它们在逻辑上变为一个字典。然后，这些字典并 不是真的合并在一起了，ChainMap 类只是在内部创建了一个容纳这些字典的列表并重 新定义了一些常见的字典操作来遍历这个列表。 作为 ChainMap 的替代，你可能会考虑使用 update() 方法将两个字典合并。12345678910&gt;&gt;&gt; a = &#123;'x': 1, 'z': 3 &#125;&gt;&gt;&gt; b = &#123;'y': 2, 'z': 4 &#125;&gt;&gt;&gt; merged = dict(b)&gt;&gt;&gt; merged.update(a)&gt;&gt;&gt; merged['x'] 1&gt;&gt;&gt; merged['y'] 2&gt;&gt;&gt; merged['z'] 3 但是它需要你创建一个完全不同的字典对象(或者是破坏现有 字典结构)。同时，如果原字典做了更新，这种改变不会反应到新的合并字典中去。 ChainMap 使用原来的字典，它自己不创建新的字典。所以它并不会产生上面所说的结果 3. 可迭代对象3.1. 去重且保持顺序 hashable 对象 1234def dedupe(items): seen = set()for item in items:if item not in seen:yield item seen.add(item) unhashable 对象 1234def dedupe(items, key=None): seen = set()for item in items:val = item if key is None else key(item) if val not in seen:yield item seen.add(val) 3.2. 命名切片lst[a:b] -&gt; SLC = slice(a,b); lst[SLC] 好处：代码清晰可读，可维护性增加 3.3 序列出现次数最多元素collection.Counter中的most_common()方法1234from collections import Counterword_counts = Counter(words)# 出现频率最高的 3 个单词top_three = word_counts.most_common(3) Counter可以与数学运算符结合(加减) 3.4. 过滤序列 列表推导式 [n for n in lst if n&gt;0] 缺点：内存占用 生成器表达式 (n for n in lst if n&gt;0) filter()12345678values = ['1', '2', '-3', '-', '4', 'N/A', '5'] def is_int(val):try:x = int(val)return True except ValueError:return Falseivals = list(filter(is_int, values))print(ivals)# Outputs ['1', '2', '-3', '4', '5'] 3.5. 命名元组collections.namedtuple()函数通过使用一个普通的元组对象;你需要传递一个类型名和你需要的字段给它，然后它就会返回一个类，你可以初始化这个类，为你定义的字段传递值等123456789&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Subscriber = namedtuple('Subscriber', ['addr', 'joined'])&gt;&gt;&gt; sub = Subscriber('jonesy@example.com', '2012-10-19')&gt;&gt;&gt; subSubscriber(addr='jonesy@example.com', joined='2012-10-19')&gt;&gt;&gt; sub.addr'jonesy@example.com'&gt;&gt;&gt; sub.joined'2012-10-19' 命名元组的一个主要用途是将你的代码从下标操作中解脱出来。因此，如果你从数 据库调用中返回了一个很大的元组列表，通过下标去操作其中的元素，当你在表中添加 了新的列的时候你的代码可能就会出错了。但是如果你使用了命名元组，那么就不会有 这样的顾虑。 命名元组另一个用途就是作为字典的替代，因为字典存储需要更多的内存空间。如 果你需要构建一个非常大的包含字典的数据结构，那么使用命名元组会更加高效. 一个命名元组是不可更改的1234567&gt;&gt;&gt; s = Stock('ACME', 100, 123.45)&gt;&gt;&gt; sStock(name='ACME', shares=100, price=123.45)&gt;&gt;&gt; s.shares = 75Traceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: can't set attribute 如果你真的需要改变属性的值，那么可以使用命名元组实例的 _replace() 方法， 它会创建一个全新的命名元组并将对应的字段用新的值取代123&gt;&gt;&gt; s = s._replace(shares=75)&gt;&gt;&gt; sStock(name='ACME', shares=75, price=123.45)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决ubuntu文件管理器卡死情况]]></title>
    <url>%2F2018%2F08%2F14%2F%E8%A7%A3%E5%86%B3ubuntu%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8%E5%8D%A1%E6%AD%BB%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[有时会遇到Ubuntu文件管理器死掉的情况，怎么点击都没有反应， 这时只需在终端上运行ps -A | grep nautilus，查找文件管理器nautilus对应的pid, 然后sudo kill pid就可以关闭文件管理器进程， 随便点击一个文件夹就可以重启文件管理器了。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python操作excel文件]]></title>
    <url>%2F2018%2F08%2F11%2Fpython%E6%93%8D%E4%BD%9Cexcel%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[先占个坑。。。]]></content>
  </entry>
  <entry>
    <title><![CDATA[hexo添加评论功能]]></title>
    <url>%2F2018%2F08%2F11%2Fhexo%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言想着继续更新这个博客，先是改了主题，用的 anatole，一方面确实好看，而且首字母a排的靠前。。。言归正传，接着就像加个评论，这样更像一个完整的站了。虽然估计没什么会来留言哈哈。 本来想用网易云跟帖的但在网上查好像已经停用了，就用了 Valine，一个方便好用的评论系统。 使用Valine注册LeancloudValine的评论实际上是放在Leancloud上的，因此需要去注册一个账号。 Leancloud 进入网站点免费试用，注册账户后，创建一个应用，个人用选择开发板就行，创建完成后进入设置–应用Key，里面的App ID, App Key字段是接下来需要写入配置文件的。 设置Valine在主题配置文件_config.yml下，填入或修改valine设置，如下这样的： 123456789valine: enable: true # if you want use valine, please set enable: true appid: #your app id appkey: #your app key notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code avatar: retro # avatar style https://github.com/xCss/Valine/wiki/avatar-setting-for-valine placeholder: comment welcomed guest_info: nick,mail,link 然后generate一下就可以看到评论框了 就像这篇文章下面这样^_^]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-first]]></title>
    <url>%2F2018%2F08%2F04%2Fhexo-first%2F</url>
    <content type="text"><![CDATA[hexo 从零开始搭建1. 安装我是使用的环境为macbookpro，系统macos，之前已经安装过git。因此为安装hexo，需要先安装node.js。 goto https://nodejs.org/en/ ， 我选择的是LST版本。下载安装包安装就好了。在命令行使用 node -v命令查看是否安装成功。 之后安装hexo，使用npm工具就好了。 新建一个文件夹作为要存放所有blog的地方，在这个文件夹下打开终端，使用npm install -g hexo-cli命令安装hexo。 安装完成后使用hexo -v可以查看版本 2. 初始化命令123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install hexo会在指定文件夹中新建所需的文件。 文件结构： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 3. 搭到github上在github中新建repo，名称为name.github.io，其中name为自己的github名称。 然后打开blog项目，修改 _config.yml文件，配置deploy信息：1234deploy: type: git repo: https://github.com/Name/Name.github.io.git branch: master 上传到github先安装 npm install hexo-deployer-git --save 这样blog可以部署到github服务器然后别人才能浏览到再执行命令123hexo cleanhexo generatehexo deploy 然后在浏览器打开http://name.github.io就可以看到个人博客了。 4. 写文章hexo new &lt;title&gt;，然后可以再source/_posts路径下看到创建的文章了，编辑完后重新部署就可以看到了。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
